/*
 * OSCAL REST
 *
 * A draft proposal from [Easy Dynamics](https://www.easydynamics.com) of a REST API specification for interacting   with [OSCAL](https://pages.nist.gov/OSCAL/) models.  Standardized data models like OSCAL lay the groundwork for interoperability of systems, and an ecosystem of meaningful integrations can be brought to life through a standardized REST API. That interface needs to define simple CRUD operations, but should also describe how to manipulate relationships and make partial changes.  Such an API will likely see the most success across various vendors and projects when maintained by a standards body or community, and we're looking to get that conversation started with this effort.  ## Identifier Scope Note that all object identifiers are **scoped to the system** implementing the REST API   and are expected to be unique.  <details>   <summary>Example</summary>   To associate a Party with a known Component Definition with a UUID you might:   1. Search for the Party:       ```       GET /parties/search?query=bob       ```       ```       [         {           \"uuid\": \"d834ed5e-9652-4b78-87e7-a9f8686f4e60\",           \"type\": \"person\",           \"name\": \"Bob Johnson\"         }       ]       ```   2. Use the found Party's ID to associate with the component definition:       ```       PUT /component-definitions/599b6fa5-3e18-4580-bd8f-8a181776c6e8/parties/d834ed5e-9652-4b78-87e7-a9f8686f4e60       ``` </details>  ## Partial Payloads in PATCH Requests All updates to 'root' OSCAL objects via `PATCH` requests should accept a partial payload containing only the changed data and the entire updated object should be returned.  The UUID of the root object must not change in the payload and implementations should throw an error if such a request is made. <details>   <summary>Example</summary>   Example request:   ```   PATCH /system-security-plans/cff8385f-108e-40a5-8f7a-82f3dc0eaba8   {     \"system-security-plan\": {       \"uuid\": \"cff8385f-108e-40a5-8f7a-82f3dc0eaba8\",       \"metadata\": {         \"title\": \"Some New Title\"       }     }   }   ``` </details>
 *
 * API version: 0.1.0
 * Contact: info@easydynamics.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package main

import (
	"encoding/base64"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/secretsmanager"
	compserv "github.com/rhmdnd/compserv-poc/compserv"
	"github.com/spf13/viper"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

func main() {
	log.Printf("Server started")

	// Get a connection to the database so we can pass it in as a
	// dependency to the service implementations.
	c := parseConfig()
	connStr := getDatabaseConnectionString(c)

	db, err := gorm.Open(postgres.Open(connStr), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Established database connection. %v", db)

	OSCALCatalogApiService := compserv.NewOSCALCatalogApiService()
	OSCALCatalogApiController := compserv.NewOSCALCatalogApiController(OSCALCatalogApiService)

	OSCALComponentDefinitionApiService := compserv.NewOSCALComponentDefinitionApiService()
	OSCALComponentDefinitionApiController := compserv.NewOSCALComponentDefinitionApiController(OSCALComponentDefinitionApiService)

	OSCALPartyApiService := compserv.NewOSCALPartyApiService()
	OSCALPartyApiController := compserv.NewOSCALPartyApiController(OSCALPartyApiService)

	OSCALProfileApiService := compserv.NewOSCALProfileApiService()
	OSCALProfileApiController := compserv.NewOSCALProfileApiController(OSCALProfileApiService)

	OSCALSystemSecurityPlanApiService := compserv.NewOSCALSystemSecurityPlanApiService()
	OSCALSystemSecurityPlanApiController := compserv.NewOSCALSystemSecurityPlanApiController(OSCALSystemSecurityPlanApiService)

	router := compserv.NewRouter(OSCALCatalogApiController, OSCALComponentDefinitionApiController, OSCALPartyApiController, OSCALProfileApiController, OSCALSystemSecurityPlanApiController)

	log.Fatal(http.ListenAndServe(":8080", router))
}

func parseConfig() map[string]string {
	viper.SetDefault("database.port", "5432")
	viper.SetDefault("database.name", "compliance")
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	// FIXME(rhmdnd): Expand support for other configuration paths (e.g.,
	// /etc/compserv/config.yaml)
	viper.AddConfigPath("./config/")
	err := viper.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("Fatal error config file: %w \n", err))
	}
	db_host := viper.GetString("database.host")
	db_port := viper.GetString("database.port")
	db_username := viper.GetString("database.username")
	db_name := viper.GetString("database.name")
	db_secret_arn := viper.GetString("database.secret_arn")
	db_secret_region := viper.GetString("database.secret_region")

	if len(db_host) == 0 {
		log.Fatal("Database host not provided.")
		os.Exit(1)
	} else if len(db_secret_arn) == 0 {
		log.Fatal("Database password not provided as an ARN.")
		os.Exit(1)
	} else if len(db_username) == 0 {
		log.Fatal("Database username not provided.")
		os.Exit(1)
	} else if len(db_secret_region) == 0 {
		log.Fatal("Database secret region not provided.")
		os.Exit(1)
	}

	m := make(map[string]string)
	m["db_host"] = db_host
	m["db_port"] = db_port
	m["db_secret_arn"] = db_secret_arn
	m["db_username"] = db_username
	m["db_name"] = db_name
	m["secret_region"] = db_secret_region

	log.Printf("Loaded configuration file: %s", viper.ConfigFileUsed())
	return m

}

func getDatabaseConnectionString(v map[string]string) string {
	secret := getSecret(v["db_secret_arn"], v["secret_region"])
	connectionString := fmt.Sprintf("host=%s user=%s password=%s port=%s", v["db_host"], v["db_username"], secret, v["db_port"])
	return connectionString
}

func getSecret(secretName string, region string) string {
	var secretString, decodedBinarySecret string

	//Create a Secrets Manager client
	sess, err := session.NewSession()
	if err != nil {
		// Handle session creation error
		fmt.Println(err.Error())
		return secretString
	}
	svc := secretsmanager.New(sess,
		aws.NewConfig().WithRegion(region))
	input := &secretsmanager.GetSecretValueInput{
		SecretId:     aws.String(secretName),
		VersionStage: aws.String("AWSCURRENT"), // VersionStage defaults to AWSCURRENT if unspecified
	}

	// In this sample we only handle the specific exceptions for the 'GetSecretValue' API.
	// See https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html

	result, err := svc.GetSecretValue(input)
	if err != nil {
		if aerr, ok := err.(awserr.Error); ok {
			switch aerr.Code() {
			case secretsmanager.ErrCodeDecryptionFailure:
				// Secrets Manager can't decrypt the protected secret text using the provided KMS key.
				fmt.Println(secretsmanager.ErrCodeDecryptionFailure, aerr.Error())

			case secretsmanager.ErrCodeInternalServiceError:
				// An error occurred on the server side.
				fmt.Println(secretsmanager.ErrCodeInternalServiceError, aerr.Error())

			case secretsmanager.ErrCodeInvalidParameterException:
				// You provided an invalid value for a parameter.
				fmt.Println(secretsmanager.ErrCodeInvalidParameterException, aerr.Error())

			case secretsmanager.ErrCodeInvalidRequestException:
				// You provided a parameter value that is not valid for the current state of the resource.
				fmt.Println(secretsmanager.ErrCodeInvalidRequestException, aerr.Error())

			case secretsmanager.ErrCodeResourceNotFoundException:
				// We can't find the resource that you asked for.
				fmt.Println(secretsmanager.ErrCodeResourceNotFoundException, aerr.Error())
			}
		} else {
			// Print the error, cast err to awserr.Error to get the Code and
			// Message from an error.
			fmt.Println(err.Error())
		}
		return secretString
	}

	// Decrypts secret using the associated KMS key.
	// Depending on whether the secret is a string or binary, one of these fields will be populated.
	if result.SecretString != nil {
		secretString = *result.SecretString
		return secretString
	} else {
		decodedBinarySecretBytes := make([]byte, base64.StdEncoding.DecodedLen(len(result.SecretBinary)))
		len, err := base64.StdEncoding.Decode(decodedBinarySecretBytes, result.SecretBinary)
		if err != nil {
			fmt.Println("Base64 Decode Error:", err)
			return secretString
		}
		decodedBinarySecret = string(decodedBinarySecretBytes[:len])
		return decodedBinarySecret
	}
}
